# MyWebserver

Learning from 30dayMakeCppServer1.

------

#### day1

今天学习了客户端和服务器端的实现基础，前段时间只是仅仅看视频学习，发现自己动手写的时候还是相差甚远，本次学习知识：

###### 1、浅析通用地址和专用地址区别：

答： socket通用地址与socket专用地址的区别，通用地址用于bind之后的操作，但是因其需要根据协议族的不同进行位操作所以很麻烦所以我们会用专用地址来进行地址编写，然后强制转化。

###### 2、shell操作：

答：我们若是clr + c的话会杀死进程，若是clr + z只是挂起进程。

###### 3、bind，listen，accept的是否将信息写入内核文件描述符：

答：对的，在一开始socket创建描述符时就是在内核中创建的，返回的是文件描述符，我们可以利用这个文件描述符来去操作内核，这3个函数正好可以对其进行操作。

------
#### day2

今天学习了IO多路复用的知识。

###### 1、什么是IO多路复用：

答：我们首先得从阻塞I/O和非阻塞I/O谈起，阻塞I/O是当你调用read函数或其他发起进程调用的函数时，如果内部没有消息，这个时候该进程将会挂起（阻塞）这样就不能运行第二第三个进程了，这个时候我们可以用多线程来去解决，但是多线程会造成过多的系统资源浪费，比如多线程的切换会造成一些多余的开销，所以引入非阻塞I/O（不会挂起，每次调用及返回）但是非阻塞智能读取一次,当文件过多时也会造成浪费，这个时候就引入了I/O多路复用：一次系统调用轮询检查多个文件描述符，这样就解决了非阻塞1此系统调用查看1个文件描述符的问题

###### 2、IO多路复用和多线程的对比：

答：多线程：建立销毁线程时需要消耗内存资源以及占用CPU时间，如果要管理多线程，要使用锁，这样会增大编程的复杂难度，I/O多路复用：单线程轮询，降低时间复杂度，将查询交给内核，降低编程难度。

###### 3、epoll和select对比：

答：select：是将所有文件描述符都进行查询看是否活跃，而且储存有限最大1024，而epoll存储是个红黑树的存储结构，利用内核的I/O通知机制，将活跃的文件描述符添加到链表中，我们只需要对链表进行操作这样就降低了时间复杂度。对于select而言，效率是个抛物线增长，所以适用于少量文件描述符，而epoll效率则是一个直线，使用于大量的文件描述符。

###### 4、epoll两种触发模式的特点以及对比：

答：有两种触发模式，LT是水平触发（不断的监听读取），ET是边缘触发（每次只查询一次即返回）所以要用到非阻塞I/O。

###### 5、浅谈epoll的工作原理：

答：而epoll存储是个红黑树的存储结构，利用内核的I/O通知机制，将活跃的文件描述符添加到链表中，我们只需要对链表进行操作这样就降低了时间复杂度。

###### 6、什么是文件描述符：

答：Linux一切皆为文件，不管是socket还是其他文件，如果创建进程，则会有很多文件来表示这个进程，每个文件有一个代号，及文件描述符。

------
#### day3

今天的代码重构中遇到了很多问题，将C程序封装成C++面向对象的程序，这次重构让我再一次感受到OOP的强大之处，但是也遇到了许多的BUG：

###### 1、epoll_wait：是阻塞的只有当有客户端连接上服务器时（遇到相应）才会解除阻塞。

###### 2、对文件描述符的理解需要更加深刻。

###### 3、对于重构后的版本，要分清InetAddress不是真正的socket地址，所以在这个转换上我陷入了一个大坑。

###### 4、bind函数如果返回-1的话有可能你的ip或者port写错了（注意下细节hh）。

###### 5、今后需要学习一下对于多线程代码，服务器代码该如何调试。
------
#### day4

今天我们添加了Channel类，原因：我们不知道接收到的文件描述符具体是什么协议操作，有可能是http,有可能是ftp，不同的连接类型处理不同的实物。所以但仅仅从文件描述符不能判断到底需要怎样处理
所以我们用Channel类来代替fd,其中包括了：1.希望监听这个文件描述符的哪些事件（创建时用）。2.epoll返回该Channel时文件描述符正在发生的事件（接收时用）。
（具体原理还不是特别明了，我们在day5的学习中再好好研究。）

###### 1、前向声明：用于解决环状头文件引入。

------
#### day5

今天的学习非常有收获，我们学习了Reactor的设计模式，我们将其服务器改为单Reactor单线程的方式，在一个Server类内创建一个Eventloop（相当于主Reactor接收器）来监听不同的相应事件。本次的学习解决了day4遗留下的问题：Channel到底有什么意义？他是如何分开不事件的。学习了事件处理模式。我们只需要一直循环Eventloop的loop方法的到活跃的事件将其处理即可。

###### 1、Channel类有何意义：

答：Channel的精髓在于回调函数，通过绑定不同的回调函数处理不同的事件。

###### 2、什么是回调函数：

答：顾名思义，在我们的编程理念里有两种：1.函数。2.回调函数。回调函数的作用是可以在其他类中，再不创建该实例的前提下调用该实例的函数，就相当于把该类方法打包出来成为函数指针来调用。在本项目中，我们在Channel类中调用了Server的方法：1.NewConnection、2.handleReadEvent.

###### 3、std::function() & std::bind()

答：在C++11中为了方便创建回调函数，出现了两个std方法function和bind。function是用来代替函数指针的我们可以用std::function模板来创建函数指针，bind来绑定该方法中所需要的参数。它就相当于一个打包器。

###### 3、什么是Reactor

答：Reactor是一种高性能网络设计模式，比如 Redis、Nginx、Netty 等等，都运用了这个模式设计的思想。
Reactor把服务器处理模式分为了：1、Reactor 对象的作用是监听和分发事件；2、Acceptor 对象的作用是获取连接；3、Handler 对象的作用是处理业务；常用的模式有单 Reactor 单进程 / 线程；单 Reactor 多线程 / 进程；多 Reactor 多进程 / 线程；单Reactor单进程的方案不适用计算机密集型的场景，只适用于业务处理非常快速的场景比如Redis,因为Redis主要是在内存处理业务的，不用考虑CPU时间的浪费。单Reacotr多线程的方式是把业务的处理时间抽出到多个线程中执行。多Reactor多线程是最高效的处理模式：有一个MainReactor和多个SubReactor,这些SubReactor在多个线程中执行，MainReactor只负责分配到哪个SubReactor，不用管处理事件。

###### 4、阻塞 I/O,非阻塞 I/O,异步 I/O理解

答：阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。
非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。
异步 I/O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。（引用小林Coding知乎博主的比喻）

------

#### day6
今天我们实现了Acceptor类，该类实现了将接收socket于服务器类的分离，每个Acceptor都有独有的fd，并且都是由Eventloop所管理的。不过我们要注意的是：每次新建立连接的socket都是一个独立的个体，也就是说如果Acceptor消失了，不代表建立连接的socket需要消失。也就是说，建立socket的逻辑是在Server类实现的，它的生命周期是Server管理的，所以我们需要使用到回调函数。

###### 1、什么是虚函数：

答：虚函数是用来实现C++多态的一种方法，在基类中定义virtual关键字的函数，并且在子类中实现。当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定。虚函数的内存管理：我们知道普通的类将成员函数存放在代码区，变量存放在堆区，而含有虚函数的类在堆区中还含有一个函数指针：vptr，该指针指向虚函数真实实现的代码区，这也就是说sizeof()这个类，将会多出4字节的大小。我们可以得出另一个结论：虚函数可以作为析构函数，但不能作为构造函数，因为构造前还没有vptr指针。

------

#### day7

今天我们实现了Connection类，该类和Acceptor类有异曲同工之妙。

------

#### day8

今天我们实现了buffer类，我们之前使用的读缓冲区大小为1024，每次从TCP缓冲区读取1024大小的数据到读缓冲区，然后发送给客户端。这是最底层C语言的编码，在逻辑上有很多不合适的地方。比如我们不知道客户端信息的真正大小是多少，只能以1024的读缓冲区去读TCP缓冲区（就算TCP缓冲区的数据没有1024，也会把后面的用空值补满）。

###### 1、string的知识（c_str, clear和erase的区别）：

答：首先，string类的实现实际上封装着一个char*的指针，我们调用c_str实际上是返回一个const char *的指针，指的是指向字符常量的指针，即指针可以改变指向但其指向的内容不可以改变。但是如果讲c_str的返回值给一个const char * str，因为str的生命周期是由c_str的返回值是有string管理的，所以改变string的值或者直接改变str的值都是会实际改变的，请注意如果string销毁了，str也将销毁。clear是讲string的首地址指针的值改为'\0'而不是删除所有内容，erase是删除所有内容。

------

#### day9

今天我们实现了线程池，为了实现多线程的并发，我们讲线程池建立在EventLoop里，每次Channel有事件需要处理时，不再调用callback而是将事件添加到线程池上来处理，每次的事件处理都有一个线程来处理，线程池中一共有10个线程，在创建线程池时将它阻塞然后等待有add事件时notify来唤醒。

###### 1、condition_variable.wait()

void wait( std::unique_lock< std::mutex >& lock, Predicate pred );其中第一个形参必须时unique_lock,因为wait()先unlock之前获得的mutex，然后阻塞当前的执行线程。其中第二个参数pred只有为false时才会阻塞线程。


------

#### day10

今天我们改进了线程池的add函数，准确来说，这一次的学习尤其漫长，加起来快1周半了，因为中间夹杂着国庆和中秋节，玩了3，4天，由于本人C++需要补的的东西太多，中途去学习了《Effective morden C++》的完美转发部分，其中再看源码（webserver）的时候也是花了很大的劲，真是非常有难度的一次，因为休息的时间过长，之前学的东西也有点忘记。

本次学习，我们主要将Add函数改为template版本并且添加了返回值，这里使用了future技术，在任务完成后将返回值传给主线程，我们优化了添加中会进行的拷贝操作，这里也解决了之前的一个疑问，因为我们使用了emplace为什么还存在拷贝操作呢（将在下面详细说明emplace和push的区别）。我们修改了之前accpetor的epoll模式，因为接收时操作是简单快捷的，没必要使用ET边缘模式，我们用LT水平不断监听即可，可不需要将accpetor放在线程池中，并且将接收的fd改为阻塞式的，这样也可以提高并发量。我们是用单Reactor/多线程的方式实现的，我们将最大并发量达到了9000+，这里有个小坑就是，在每次打开terminal的时候要使用ulimit 将最大文件描述符改为65535，要不然最大会是默认1024而造成一系列文件描述符错误。

###### 1、完美转发，右值引用，通用引用

答：我们有时候在写函数时形参会是右值引用（T && t），但实际上这是一个很大的陷阱，他其实是一个通用引用，也就是说，它可以作为左值引用，也可以作为右值引用来调用，所以在函数体内如果使用移动构造（move）或者拷贝构造（直接传左值）都是可以的，所以我们会在这里误以为只能传递右值。因此完美转发诞生了，他就是用来解决实参传来什么形参就应当是什么的问题。它使用到关键字forward。详细内容可以继续阅读《Effective morden C++》。

###### 2、emplace和push的区别

答：在C++11中加入了emplace方法，他与push的区别就是在于：如果用临时构造时emplace主要是在实例中构造，而push会构造一个临时量再进行move,这里会降低效率，情况1：如果传入左值都是调用拷贝构造，情况2：如果传入右值都是调用移动构造，情况3：如果创建一个对象，则都是先调用构造函数再掉用移动构造，情况4：如果临时创建一个对象，emplace性能优于push，因为少去了移动构造，直接构造。我们再源码中可以看到，push其实如果传入右值的话会优化是用emplace,我们再emplace源码中看到了是用完美转发的方法，这也就说如果临时创建对象时一路转发到构造函数上，无需构造临时变量，而push构造出来临时变量后会再进行一次移动构造。

###### 3、future/promise and async()

答：future和promise实际是用来解决普通是用锁和条件变量造成的编程复杂，future其实就相当于你创造一个异步线程，这个线程将会再未来任务完成时，给主线程返回结果，如果你想让主线程给子线程传递东西的话，那就是用promise,然后调用get_future的到future对象，将这个future传递给子线程，然后再主线程中设置value,这个时候子线程就可以得到value了。当然如果有多个子异步线程想要这个promise的future时，我们可以创建share_future来管理。

###### 4、lamda表达式

答：\[拷贝/移动]（参数列表）{函数体}，lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。我们再中括号内来选择是否捕获外部变量

###### 5、package_task()

答：package_task()相当于是对任务进行包装，我们可以用到bind函数，然后将这个packge放到队列里，然后是用future来获取这个package未来的返回值，以便后续操作。

###### 6、参数包

答：就是可以将函数设置为不定参数，如果有一个函数调用为foo(11,"sash",dd)你不知道参数到底是什么类型，这个时候就可以用到template< class F, class... Args>，F为函数，Args为参数。

------

#### day10

今天的学习中，我们采取了主Reactor和子Reactor分离的设计模式，将线程池从Eventloop中脱离出来，它的生命周期应该由Server来管理，我们设计了一个Vector来存放subReactor---Eventloop,每个线程的任务将会是Eventloop的Pool.


------

#### day11

这一次的学习中，我们将Connection类完善化，将echo的逻辑呈现在server里通过lamda构造回调函数给Connection然后通过setOnConnection将逻辑设计到channel中，最后当Epool循环时通过handle来调用，本次学习的bug可谓是说不尽了，教程中的源码也有很多错误，我们要注意，client是不能调用Close()的，Close是服务器调用的，客户端只能监听。另外我们学习了宏语法，以及如何禁止复制构造或者移动构造

###### 1、为什么要禁止类的复制构造函数和赋值运算符？

默认生成的拷贝构造函数，会直接拷贝buf_的值，导致两个Widget对象指向同一个缓 冲区，这会导致析构的时候两次删除同一片区域的问题（这个问题又叫双杀问题）

###### 2、C++ 枚举类型：

答：枚举类型 (enumeration)是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合，我们通常利用枚举类型来定义一个对象的状态。


